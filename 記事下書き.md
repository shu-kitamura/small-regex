# Rustで正規表現エンジンを実装した話 その①

## 概要

以下の2点から、Rustで正規表現エンジンを実装しました。  

* Rustを学ぶ
* 正規表現の仕組みを理解する

知識の整理をかねて、実装したコードの解説を記載します。  
ソースコードは以下のリポジトリに含まれています。

本記事で使用するコードは、正規表現エンジンの処理を解説のしやすさを優先して、エラー処理を考慮していません。  

## 正規表現エンジンの種類

正規表現エンジンには、以下の2種類の実装があります。

* VM型
* DFA型

今回実装したエンジンはVM型です。  
2種類のエンジンの違いや、メリットなどに興味がある方は以下の本を読むことをお勧めします。  

[正規表現技術入門](https://gihyo.jp/book/2015/978-4-7741-7270-5)

## 処理の流れ

VM型の正規表現エンジンは大きく分けると、以下の3つの処理を行っています。  

1. パターンをパースし、抽象構文木(AST)を生成する  
2. ASTから命令列を生成する  
3. 文字列がパターンと一致するか評価する  

# Rustで正規表現エンジンを実装した話 その②

その①でVM型の正規表現エンジンは以下の3つの処理を行っていると説明しました。  

1. パターンをパースし、抽象構文木(AST)を生成する  
2. ASTから命令列を生成する
3. 文字列がパターンと一致するか評価する

今回、解説するのは「1. パターンをパースし、抽象構文木(AST)を生成する」処理です。  

## 概要

parser モジュール(parser.rs)に AST を表す型と、ASTを生成する関数を実装します。

## parser

parserはパターンから、以下のAST型オブジェクトを生成します。

```rust
pub enum AST {
    Char(char),             // 文字に対応する型
    Plus(Box<AST>),         // '+'に対応する型
    Star(Box<AST>),         // '*'に対応する型
    Question(Box<AST>),     // '?'に対応する型
    Or(Box<AST>, Box<AST>), // '|'に対応する型
    Seq(Vec<AST>),　        // 連接に対応する型
}
```

例えば`a|b`というパターンを受け取った場合、  
`Or(Char(a), Char(b))`というASTを生成します。  

ASTの生成は、parse関数で行います。
for文で、パターンから1文字ずつ取り出し、  
match式で、取り出した文字列に対応した処理を実行します。  

以下、parse関数の実装です。  
match式の中の各文字列に対する処理は、この後実装を記載します。  
```rust
pub fn parse(pattern: &str) -> AST {
    let mut seq: Vec<AST> = Vec::new(); // 現在のコンテキスト
    let mut or: Vec<AST> = Vec::new(); // Orのコンテキスト
    let mut stack: Vec<(Vec<AST>, Vec<AST>)> = Vec::new(); // コンテキストを一時的に退避させるスタック

    let mut is_escape: bool = false;

    for c in pattern.chars() {
        if is_escape {
            // エスケープ文字を受け取ったときの処理
            unimplemented!();
        }

        match c {
            '+' | '*' | '?' => {
                // +, *, ? を受け取ったときの処理
                unimplemented!();
            },
            '(' => {
                // ( を受け取ったときの処理
                unimplemented!();
            },
            ')' => {
                // ) を受け取ったときの処理
                unimplemented!();
            }
            '|' => {
                // | を受け取ったときの処理
                unimplemented!();
            },
            '\\' => is_escape = true,
            _ => seq.push(AST::Char(c))
        };
    }

    if !stack.is_empty() {
        panic!()
    }

    if !seq.is_empty() {
        or.push(AST::Seq(seq));
    }

    fold_or(or)
}
```

以下、各文字列に対する処理を実装していきます。

### 通常の文字のパース  

通常の文字のパースは、文字列に対応するASTを生成し、`seq`に追加する。  
実装した処理は以下です。  

```rust
        match c {
            // (略)
            _ => seq.push(AST::Char(c))
        };
```

### エスケープ文字のパース  

エスケープ文字のパースは、パターンから取り出した文字が`\\`だったときに、  
その次の文字をエスケープ文字としてASTを生成する。   
実装した処理は以下です。  

```rust
    for c in pattern.chars() {
        if is_escape {
            seq.push(parse_escape(c));
            is_escape = false;
            continue;
        }

        match c {
            // (略)
            '\\' => is_escape = true,
    }
```

1. `\\`を受け取った場合、`is_escape`を`true`にする  
2. `is_escape`が`true`になったことで、次のループでif文内の処理を実行する。  
3. `parse_escape`関数(この後実装する)でASTを生成し、生成したASTを`seq`に追加する。  
4. `is_escape`を`false`に変更する。

parse_escape関数は文字を受け取り、受け取った文字がエスケープ文字で使用可能な文字の場合、ASTを生成する。  
エスケープ文字として使用可能な文字は、`\\`, `(`, `)`, `|`, `+`, `*`, `?`の7種類。  

parse_escape関数の実装は以下です。  
受け取った文字がエスケープ文字で使用不可能な場合、プログラムを強制終了するようになっています。  
(その①で記載した通り、エラー処理は考慮していません)  

```rust
fn parse_escape(c: char) -> AST {
    match c {
        '\\' | '(' | ')' | '|' | '+' | '*' | '?' => AST::Char(c),
        _ => panic!(),
    }
}
```

### +, *, ? のパース

`*`, `+`, `?`のパースは、直前のASTを取得し、  
`*`, `+`, `?`に対応したASTを生成し、`seq`に追加する。  

実装した処理は以下です。  

```rust
        match c {
            '*' | '+' | '?' => {
                let prev_ast: AST = seq.pop().unwrap();
                let ast: AST = parse_qualifier(c, prev_ast);
                seq.push(ast);
            },
```

上記の処理は、以下を行っています。  
1. `seq.pop()`で直前のASTを取得し、変数`prev_ast`に格納。  
2. `parse_qualifier`関数(この後実装する)で、`*`, `+`, `?`に対応するASTを生成。  
3. 生成したASTを`seq.push(ast)`でseqに追加。

parse_qualifier関数は、文字と直前のASTを受け取り、受け取った文字に対応したASTを生成します。  
parse_qualifier関数の実装は以下です。  

```rust
fn parse_qualifier(c: char, prev: AST) -> AST{
    match c {
        '*' => AST::Plus(Box::new(prev)),
        '+' => AST::Star(Box::new(prev)),
        '?' => AST::Question(Box::new(prev)),
        _ => unreachable!()
    }
}
```

例えば、パターンが`a+`の場合、  

* 受け取る文字列 : `+`
* 直前のAST : `Char(a)`

となり、parse_qualifierを実行すると、`Plus(Char(a))`というASTが生成されます。  

### | のパース

`|`のパースは、`|`の前のASTを別の配列に退避させます。  
実装した処理は以下です。  

```rust
        match c {
            // (略)
            '|' => {
                or.push(AST::Seq(seq));
                seq = Vec::new();
            }
```

上記の処理は以下を行っています。

1. `or`に`seq`を追加。  
2. `seq`を空にする。  

例えば、`a|b`というパターンの場合、  

`|`を処理する際、`seq`には`Char(a)`が含まれている。  
この`Char(a)`を`or`に追加し、`seq`を空にする。  

### ( のパース

`(`のパースは、`(`を受け取った時点でのASTを、stackに退避させます。  

```rust
        match c {
            // (略)
            '(' => {
                stack.push((seq, or));
                seq = Vec::new();
                or = Vec::new();
            }
```

上記の処理は以下を行っています。  

1. `seq`, `or`を`stack`に追加。  
2. `seq`, `or`を空にする。

### ) のパース

stack から AST を取り出し、`seq`, `or`にそれぞれ代入します。  

```rust
        match c {
            // (略)
            ')' => {
                let (mut prev, prev_or) = stack.pop().unwrap();

                if !seq.is_empty() {
                    or.push(AST::Seq(seq));
                }
                prev.push(fold_or(or));

                seq = prev;
                or = prev_or;
            }
```

途中で実行している、`fold_or`は以下の実装です。  
`or`から or のAST を生成します。  

```rust
fn fold_or(mut or: Vec<AST>) -> AST {
    if or.len() > 1 {
        let mut ast: AST = or.pop().unwrap();
        or.reverse();
        for s in or {
            ast = AST::Or(Box::new(s), Box::new(ast));
        }
        ast
    } else {
        or.pop().unwrap()
    }
}
```

## Parser の完成形

Parser モジュール(parser.rs)の完成形は以下です。  
[GitHub - parser.rs](https://github.com/shu-kitamura/small-regex/blob/main/src/parser.rs)


# Rustで正規表現エンジンを実装した話 その③

# 概要

その①でVM型の正規表現エンジンは以下の3つの処理を行っていると説明しました。  

1. パターンをパースし、抽象構文木(AST)を生成する  
2. ASTから命令列を生成する
3. 文字列がパターンと一致するか評価する

今回、解説するのは「2. ASTから命令列を生成する」処理です。  
compiler モジュール(compiler.rs)に 命令列を表す型と、AST から命令列を生成する関数を実装します。   

# 命令列と処理順所  

compiler モジュールでは、ASTを解析して、命令の実行位置を示すプログラムカウンタと命令列を生成します。  

命令には以下の４種類があります。  

* Char : 文字列のマッチングを行い、現在の文字列と指定された文字が一致する場合、次の命令に進める命令
* Match : マッチ成功を表す命令
* Jump : 指定されたプログラムカウンタの命令を実行する
* Split : 指定された2つのプログラムカウンタの命令を実行する

これらの命令を組み合わせ、正規表現を評価します。  

例えば、パターンに`ab(c|d)`が指定された場合、ASTは以下になります。  
```
Char(a)
Char(b)
Or(
    Char(c),
    Char(d)
)
```

上記の AST を解析した場合、以下のプログラムカウンタ(PC)と命令が生成されます。  
```
 PC  :  命令  
0000 : Char(a)
0001 : Char(b)
0002 : Split(0003, 0005)
0003 : Char(c)
0004 : Jump(0006)
0005 : Char(d)
0006 : Match
```

評価は以下の順序で実行されます。  
評価対象の文字列として`abc`を受け取った、以下の順序で評価が実行されます。  

1. a が現在の文字列として渡され、Char(a) 命令が実行されます。 
   a と ()内の a が一致するため、次の命令に進みます。  
2. b が現在の文字列として渡され、Char(b) 命令が実行されます。  
   b と ()内の b が一致するため、次の命令に進みます。  
3. Split(0003, 0005)命令が実行されます。 
   0003 の命令である Char(c) と 0005 の命令である Char(d) がそれぞれ実行されます。  
4. c が現在の文字列として渡され、Char(c) 命令が実行されます。  
   c と ()内の c が一致するため、次の命令に進みます。  
5. Jump(0006) が実行され、0006 の命令である Match が実行されます。  
6. Match が実行されたので、マッチ成功となります。  

上記の 1～6 の順序で評価が実行され、  
パターン`ab(c|d)`に対して、文字列`abc`が一致すると評価されます。  

# compiler の実装

ここから、命令列・Compiler型を定義し、  
AST から命令列を生成する関数を実装ていきます。  

## 命令列  

列挙型`Instruction`を、以下の内容で実装しました。  
列挙型の各値が4つの命令を表しています。  

```rust
#[derive(Debug, PartialEq)]
pub enum Instruction {
    Char(char),
    Match,
    Jump(usize),
    Split(usize, usize),
}
```

## Compiler 型  

Compiler 型は以下の内容で実装しました。  
まず`gen_code`を実行し、その中で`gen_expr`を実行します。  
`gen_expr`は、受け取った AST に対応する関数を実行して、命令列を生成します。  
「対応する関数」の説明は、下で行っていきます。  

```rust
#[derive(Default, Debug)]
struct Compiler {
    p_counter: usize,              // プログラムカウンタ
    instructions: Vec<Instruction> // 命令列
}

impl Compiler {
    fn gen_code(&mut self, ast: &AST) {
        self.gen_expr(ast);
        self.instructions.push(Instruction::Match);
    }

    fn gen_expr(&mut self, ast: &AST) {
        match ast {
            AST::Char(c) => self.gen_char(*c),
            AST::Or(e1, e2) => self.gen_or(e1, e2),
            AST::Plus(ast) => self.gen_plus(ast),
            AST::Star(ast) => self.gen_star(ast),
            AST::Question(ast) => self.gen_question(ast),
            AST::Seq(v) => self.gen_seq(v),
        }
    }

    fn gen_char() {
        unimplemented!()
    }

    fn gen_or() {
        unimplemented!()
    }

    fn gen_plus() {
        unimplemented!()
    }

    fn gen_star() {
        unimplemented!()
    }

    fn gen_question() {
        unimplemented!()
    }

    fn gen_seq() {
        unimplemented!()
    }
}
```

### gen_char の実装  

`gen_char`は、`AST::Char`型に対応する命令を生成します。  
`Instruction::Char`を生成します。  

```rust
    fn gen_char(&mut self, c: char) {
        self.p_counter += 1;
        self.instructions.push(Instruction::Char(c));
    }
```

### gen_or の実装  

`gen_or`は、`AST::Or`に対応する命令を生成します。  
`AST::Or(Char(a), Char(b))`というASTを受け取った場合、  
以下の命令を生成します。  
```
0000 : Split(0001, 0003)
0001 : Char(a)
0002 : Jump(0004)
0003 : Char(b)
0004 : ...次のASTに対応する命令
```

以下のように実装しました。  

```rust
    fn gen_or(&mut self, expr1: &AST, expr2: &AST) {
        let split_counter: usize = self.p_counter;

        // カウンタをインクリメントし、split を挿入する
        // 第二引数は、expr2のコードの開始のカウンタを指定するため、この時点では決まらない
        // ここでは仮の数値(0)を入れて。数値は後で更新する
        self.p_counter += 1;
        self.instructions.push(Instruction::Split(self.p_counter, 0));

        // 1つ目の AST を再帰的に処理する
        self.gen_expr(expr1);

        let jump_counter: usize = self.p_counter;

        // カウンタをインクリメントし、split を挿入する。
        // 引数は、expr2 のコードの次のカウンタを指定するため、この時点では決まらない
        // ここでは仮の数値(0)を入れて。数値は後で更新する
        self.p_counter += 1;
        self.instructions.push(Instruction::Jump(0));

        // Splitの第二引数を更新する
        if let Some(Instruction::Split(_, right)) = self.instructions.get_mut(split_counter) {
            *right = self.p_counter;
        };

        // 2つ目の AST を再帰的に処理する
        self.gen_expr(expr2);

        // Jumpの引数を更新する
        if let Some(Instruction::Jump(arg)) = self.instructions.get_mut(jump_counter) {
            *arg = self.p_counter;
        }
    }
```

### gen_plus の実装  

`gen_plus`は、`AST::Plus`に対応する命令を生成します。  
`AST::Plus(Char(a))`というASTを受け取った場合、  
以下の命令を生成します。  

```
0000 : Char(a)
0001 : Split(0000, 0002)
0002 : ...次のASTに対応する命令
```

以下のように実装しました。  

```rust
    fn gen_plus(&mut self, ast: &AST) {
        let left: usize = self.p_counter;
        // AST を再帰的に処理する
        self.gen_expr(ast);

        // カウンタをインクリメントし Split を挿入する
        self.p_counter += 1;
        self.instructions.push(Instruction::Split(left, self.p_counter));
    }
```

### gen_star の実装

`gen_star`は、`AST::Star`に対応する命令を生成します。  
`AST::Star(Char(a))`というASTを受け取った場合、  
以下の命令を生成します。  

```
0000 : Split(0001, 0003)
0001 : Char(a)
0002 : Jump(0000)
0003 : ...次のASTに対応する命令
```

以下のように実装しました

```rust
    fn gen_star(&mut self, ast: &AST) {
        let split_count: usize = self.p_counter;

        // カウンタをインクリメントし、split を挿入する

        // 第二引数は、後に出てくる Jump のカウンタの数値を示すものであり、この時点では決まらないので仮の数値(ここでは 0 )を入れる
        // 仮の数値は、Jump を挿入した後に更新する
        self.p_counter += 1;
        self.instructions.push(Instruction::Split(self.p_counter, 0));

        // AST を再帰的に処理する
        self.gen_expr(ast);
        
        // カウンタをインクリメントし、Jump を挿入する
        self.p_counter += 1;
        self.instructions.push(Instruction::Jump(split_count));

        // 仮の数値としていた Split の第二引数を更新する
        if let Some(Instruction::Split(_, right)) = self.instructions.get_mut(split_count) {
            *right = self.p_counter;
        }
    }
```

### gen_question の実装

`gen_question`は、`AST::Question`に対応する命令を生成します。  
`AST::Question(Char(a))`というASTを受け取った場合、  
以下の命令を生成します。  

```
0000 : Split(0001, 0002)
0001 : Char(a)
0002 : ...次のASTに対応する命令
```

以下のように実装しました  

```rust
    fn gen_question(&mut self, ast: &AST) {
        let split_count: usize = self.p_counter;
        // カウンタをインクリメントし、split を挿入する
        // 第二引数は、この時点では決まらないので仮の数値(ここでは 0 )を入れる
        // 仮の数値は、後に更新する
        self.p_counter += 1;
        self.instructions.push(Instruction::Split(self.p_counter, 0));

        // AST を再帰的に処理する
        self.gen_expr(ast);

        // 仮の数値としていた Split の第二引数を更新する
        if let Some(Instruction::Split(_, right)) = self.instructions.get_mut(split_count) {
            *right = self.p_counter;
        }
    }
```

### gen_seq の実装  

`gen_seq`は、`AST::Seq`に対応する命令を生成します。  
`AST::Seq`の中身は`AST::Seq(vec![Char(a), Char(b)])`のように配列となっています。  
配列の中のASTに対して、それぞれ`gen_expr`を実行し、命令を生成します。  

以下のように実装しました。  

```rust
    fn gen_seq(&mut self, vec:&Vec<AST>) {
        for ast in vec {
            self.gen_expr(ast)
        }
    }
```

Compiler 型の実装は以上です。  

最後に、外に公開するAPIとなる関数`compile`を実装します。  

```rust
pub fn compile(ast: &AST) -> Vec<Instruction> {
    let mut compiler: Compiler = Compiler::default();
    compiler.gen_code(ast);
    compiler.instructions
}
```

上記の関数は、以下の処理をしています。  

1. Compiler 型をデフォルト値で初期化
2. 命令列を生成
3. 生成された命令列を返す  

