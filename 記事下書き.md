# Rustで正規表現エンジンを実装した話 その①

## 概要

以下の2点から、Rustで正規表現エンジンを実装しました。  

* Rustを学ぶ
* 正規表現の仕組みを理解する

知識の整理をかねて、実装したコードの解説を記載します。  
ソースコードは以下のリポジトリに含まれています。

本記事で使用するコードは、正規表現エンジンの処理を解説のしやすさを優先して、エラー処理を考慮していません。  

## 正規表現エンジンの種類

正規表現エンジンには、以下の2種類の実装があります。

* VM型
* DFA型

今回実装したエンジンは、VM型です。  
2種類のエンジンの違いや、メリットなどに興味がある方は以下の本を読むことをお勧めします。  

[正規表現技術入門](https://gihyo.jp/book/2015/978-4-7741-7270-5)

## 処理の流れ

VM型の正規表現エンジンは大きく分けると、以下の3つの処理を行っています。  

1. パターンをパースし、抽象構文木(AST)を生成する  
2. ASTから命令列を生成する  
3. 文字列がパターンと一致するか評価する  

# Rustで正規表現エンジンを実装した話 その②

その①でVM型の正規表現エンジンは以下の3つの処理を行っていると説明しました。  

1. パターンをパースし、抽象構文木(AST)を生成する  
2. ASTから命令列を生成する
3. 文字列がパターンと一致するか評価する

今回、解説するのは「1. パターンをパースし、抽象構文木(AST)を生成する」処理です。  

## Parser

parserはパターンから、以下のAST型オブジェクトを生成します。

```rust
pub enum AST {
    Char(char),             // 文字に対応する型
    Plus(Box<AST>),         // '+'に対応する型
    Star(Box<AST>),         // '*'に対応する型
    Question(Box<AST>),     // '?'に対応する型
    Or(Box<AST>, Box<AST>), // '|'に対応する型
    Seq(Vec<AST>),　        // 連接に対応する型
}
```

例えば`a|b`というパターンを受け取った場合、  
`Or(Char(a), Char(b))`というASTを生成します。  

ASTの生成は、parse 関数で行います。
for文で、パターンから1文字ずつ取り出し、  
match式で、取り出した文字列に対応した処理を実行します。
```rust
pub fn parse(pattern: &str) -> AST {
    let mut seq: Vec<AST> = Vec::new(); // ASTを追加するVec
    let mut seq_or: Vec<AST> = Vec::new(); // ___
    let mut stack: Vec<(Vec<AST>, Vec<AST>)> = Vec::new(); // 処理中のASTを退避させる

    let mut is_escape: bool = false;

    for c in pattern.chars() {
        if is_escape {
            is_escape = false;
            seq.push(parse_escape(c));
        }
        match c {
            '+' | '*' | '?' => {
                // +, *, ? を受け取ったときの処理
                unimplemented!();
            },
            '(' => {
                let prev: Vec<AST> = take(&mut seq);
                let prev_or: Vec<AST> = take(&mut seq_or);
                stack.push((prev, prev_or));
            },
            ')' => {
                let (mut prev, prev_or) = stack.pop().unwrap();

                if !seq.is_empty() {
                    seq_or.push(AST::Seq(seq));
                }
                prev.push(fold_or(seq_or));

                seq = prev;
                seq_or = prev_or;
            }
            '|' => {
                let prev: Vec<AST> = take(&mut seq);
                seq_or.push(AST::Seq(prev));
            },
            '\\' => is_escape = true,
            _ => seq.push(AST::Char(c))
        };
    }
    // 閉じカッコが足りないエラー
    if !stack.is_empty() {
        panic!()
    }

    if !seq.is_empty() {
        seq_or.push(AST::Seq(seq));
    }

    fold_or(seq_or)
}
```

### +, *, ?のパース

`*`, `+`, `?`のパースは、parseのmatch式の以下の部分で実行します。  
直前のASTを取得し、`*`, `+`, `?`に対応したASTを生成する処理を実装します。  

実装した処理は以下です。  

```rust
        match c {
            '*' | '+' | '?' => {
                // +, *, ? を受け取ったときの処理
                let prev_ast: AST = seq.pop().unwrap();
                let ast: AST = parse_qualifier(c, prev_ast);
                seq.push(ast);
            },
```

上記の処理は、以下を行っています。  
1. `seq.pop()`で直前のASTを取得し、変数`prev_ast`に格納。  
2. `parse_qualifier`関数(この後実装する)で、`*`, `+`, `?`に対応するASTを生成。  
3. 生成したASTを`seq.push(ast)`でseqに追加。

parse_qualifier関数は、文字列と直前のASTを受け取り、受け取った文字列に対応したASTを生成します。  
parse_qualifier関数の実装は以下です。  

```rust
fn parse_qualifier(c: char, prev: AST) -> AST{
    match c {
        '*' => AST::Plus(Box::new(prev)),
        '+' => AST::Star(Box::new(prev)),
        '?' => AST::Question(Box::new(prev)),
        _ => unreachable!()
    }
}
```

例えば`a+`のようなパターンの場合、  

* 受け取る文字列 : `+`
* 直前のAST : `Char(a)`

となり、parse_qualifierを実行すると、`Plus(Char(a))`というASTが生成されます。  

以下のテストで確かめることができます。  

```rust
    #[test]
    fn test_qualifier() {
        let plus_ast: AST = AST::Plus(Box::new(AST::Char('a')));
        assert_eq!(parse_qualifier('+', AST::Char('a')), plus_ast);
    }
```

`*`, `?`の受け取った場合の挙動も確認したい場合は、  
上記のテストに以下の処理を追加してみてください。  

```rust
        let star_ast: AST = AST::Star(Box::new(AST::Char('a')));
        assert_eq!(parse_qualifier('*', AST::Char('a')), star_ast);

        let question_ast: AST = AST::Question(Box::new(AST::Char('a')));
        assert_eq!(parse_qualifier('?', AST::Char('a')), question_ast);
```

### ()のパース

### | のパース

### .(ピリオド)のパース

### エスケープされた文字のパース

### 通常の文字のパース

